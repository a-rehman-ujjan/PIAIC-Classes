Welcome to the TypeScript Learning Journey! This README provides an overview of the topics covered in each class.

üìö **Note:** This README is a work in progress. As more classes are covered, I will continue updating the file with detailed summaries, topics, and assignments. Stay tuned for comprehensive insights into TypeScript and web development concepts!

# Repo Map üó∫Ô∏è
- [**Class 1: Introduction to TypeScript, Web Concepts, Next.js and Serverless Technology**](https://github.com/a-rehman-ujjan/PIAIC-Classes/edit/main/README.md#class-1-introduction-to-typescript-and-web-concepts)
- [**Class 2: TypeScript Fundamentals, Variables, Primitive Data Types, Template Literals and Operators In Typescript**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-2-typescript-fundamentals)
- [**Class 3: Functions, Arrays, and User Input**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-3-functions-arrays-and-user-input)
- [**Class 4: Return Type Annotations, Arrow Function, Conditional Statements, and Loops**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-4-conditional-statements-and-loops)
- [**Class 5: CommonJS Modules vs. ECMA Modules, Asynchronous vs. Synchronous Operations, Aync Await Syntax, Inquirer and Chalk Librarie**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-5-modules-and-asynchronous-operations)
- [**Class 6: Typescript Unions, Aliases, Type literals, TypeScript Objects, and NPM**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-6-advanced-typescript-concepts-and-package-management)
- [**Class 7: Interfaces, Type Compatibility, Structural & Nominal Typing, and Fresh & Stale Objects**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-7-typescript-interfaces-and-type-compatibility)
- [**Class 8: Intersections in TypeScript, Type-Casting, "any," "unknown," and "never" Types**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-8-advanced-typescript-type-concepts)
- [**Class 9: Enums, Arrays, Functions, and Async in TypeScript**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-9-enums-arrays-functions-and-async-in-typescript)
- [**Class 10: Asynchronous Programming in TypeScript, callback functions, and Promises**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-10-asynchronous-programming-in-typeScript-callback-functions-and-promises)

# Class 1: Introduction to TypeScript and Web Concepts

- **`TypeScript Introduction:`** [TypeScript](https://www.typescriptlang.org/) is a programming language that builds upon JavaScript by adding static type-checking and other features. It enhances code quality and helps catch errors early in development.
- **`Web Concepts:`** Understand the evolution from Web 1.0 to Web 2.0 to Web 3.0: These terms refer to different stages in the evolution of the World Wide Web. Web 1.0 was the static web of early days, Web 2.0 brought interactive and social elements, and Web 3.0 aims to create a more intelligent, decentralized web.
- **`Introduction to Next.js:`**  Next.js is a popular React framework for building web applications. It enhances React with features like server-side rendering and routing.
- **`Serverless Technology:`** [Serverless computing](https://www.cloudflare.com/learning/serverless/what-is-serverless/) allows developers to focus on writing code without managing server infrastructure. It automatically scales based on demand.
- ## Assignments üìö:
  - Install development tools and console log "Hello, World!" using TypeScript.
- ### [Typescript Slides](https://docs.google.com/presentation/d/1-7Kb3laJjJ68mOTF9v0fHImk5vTol0CeE43Sg8hoUXQ/mobilepresent?slide=id.gcb9a0b074_1_0)
- ### [Getting Started Exercises](https://github.com/panaverse/typescript-node-projects/blob/main/getting-started-exercises.md)
- ### [Advanced Typescript Penaverse GitHub](https://github.com/panaverse/learn-typescript)
- ### [Class 1 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-1)

# Class 2: TypeScript Fundamentals

- **`Programming Environment Setup:`** Configure [`Node.js`](https://nodejs.org/en), [`Visual Studio Code`](https://code.visualstudio.com/), and [`TypeScript`](https://www.typescriptlang.org/download) to create a development environment.
- **`Variables In Typescript:`**  A Variable is a named container or storage location that holds a value. It's used to store and manage data that a program needs to work with. In TypeScript variables are used to store different types of values, such as numbers, strings, objects, arrays, and more To use them, declare with `let`, `const`, or `var`, assign values, and manipulate as needed
- **`Primitive Data Types:`** Explore string, number, boolean, undefined, Symbol, BigInt, and null types.
- **`Template Literals:`**  Creating strings with embedded expressions for easier concatenation and formatting.
- **`Operators In Typescript:`** Using arithmetic, assignment, comparison, and logical operators to manipulate values.
- ### Online Recorded Sessions & videos üì∫:
  - [Operators](https://www.youtube.com/watch?v=wxS7j9q0nyc)
  - [Template Literals](https://www.youtube.com/watch?v=PFzeMUojeQY&t=80s&pp=ygUadGVtcGxhdGUgbGl0ZXJhbHMgaW4gaGluZGk%3D)
  - [Primitive Data Types](https://youtu.be/qpU3WIqRz9I?list=PLu0W_9lII9ahR1blWXxgSlL4y9iQBnLpR)
  - [Variables (let, var & const)](https://www.youtube.com/watch?v=Icev9Oxf0WA&list=PLu0W_9lII9ahR1blWXxgSlL4y9iQBnLpR&index=3&pp=iAQB)
- ## Assignments üìö:
  - Complete assignments related to variables, types, and operators.
- ### [Class 2 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-2)

# Class 3: Functions, Arrays, and User Input

- **`Prompt Library:`** Learn how to take user input using the [Prompt library](https://www.npmjs.com/package/prompt).
- **`Functions in TypeScript:`** Functions in TypeScript are named code blocks used to encapsulate and reuse sets of instructions, enhancing code organization and maintainability.
- **`Array in TypeScript:`** Arrays in TypeScript are data structures that allow you to store collections of values of the same or different types. They are a fundamental part of programming and are used to manage lists of items efficiently. 
- ### Online Recorded Sessions & videos üì∫:
  - Functions: [Part 1](https://www.youtube.com/watch?v=8yc2Yd8kJ_E) & [Part 2](https://www.youtube.com/watch?v=iRan4VCOy0A)
  - Array & Array Methods: [Part 1](https://www.youtube.com/watch?v=S7FfBHs-_BU), [Part 2](https://www.youtube.com/watch?v=ScuESgM3KWE) & [Part 3](https://www.youtube.com/watch?v=dCMt2lr5Hrs)
- ## Assignments üìö:
  - **Building a grading system:** Assigned students to build a grading system using user input and conditional statements.
  - **User input handling with Prompt:** Practically implemented user input capture using Prompt.
- ### [Class 3 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-3)

# Class 4: Conditional Statements and Loops

- **`Return Type Annotations:`** A return [type annotation](https://www.tektutorialshub.com/typescript/type-annotation-in-typescript/) in TypeScript specifies the type of value that a function will provide as its output. It helps clarify what the function returns and catches type-related errors.
- **`Arrow Function:`** An arrow function is a more concise way to define functions in JavaScript and TypeScript. It provides a shorter syntax compared to traditional function expressions. Arrow functions were introduced in ECMAScript 6 (ES6) and have become a popular choice for writing functions in modern JavaScript and TypeScript code.
- **`Conditional Statements:`** Conditional statements are programming constructs that allow you to make decisions in your code based on certain conditions. They control the flow of your program by executing different blocks of code depending on whether a specified condition is true or false.
- **`Nested Statements:`** Nested statements are programming constructs where one or more statements are placed within another statement's block of code. We use nested statements to build more complex logic and implement decision-making processes that involve multiple levels of conditions.
- **`For Loops:`** A "for loop" is a programming construct that allows you to repetitively execute a block of code for a predetermined number of iterations. It consists of three main components: initialization, a condition, and an iteration statement.
- ### Online Recorded Sessions & videos üì∫:
  - [Arrow Function](https://www.youtube.com/watch?v=44aVMRtxKyc)
  - Conditional Statements: [Part 1](https://www.youtube.com/watch?v=MrRJqVtxETs) & [Part 2](https://www.youtube.com/watch?v=bGjWAbMfkNE)
  - [Loops](https://www.youtube.com/watch?v=QsaHgcjPqH8)
- ## Assignments üìö:
  - Solve assignments related to implementing conditional statements and loops. ([Example](https://github.com/usmanashrf/typescript-batch48/blob/main/Morning-section/class-4/index.ts))
- ### [Class 4 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-4)

# Class 5: Modules and Asynchronous Operations

- **`CommonJS Modules vs. ECMA Modules:`** Difference between CommonJS and ECMAScript modules lies in their syntax, loading mechanisms, and compatibility with different environments. While CommonJS is commonly used in Node.js and follows a synchronous approach, ECMAScript modules are used both in browsers and Node.js, and they use asynchronous loading with a more structured syntax.
- **`Asynchronous vs. Synchronous Operations:`**
  - **Synchronous Operations:** Blocking, sequential execution, and tasks are completed in a specific order. Execution follows a single-threaded approach.
  - **Asynchronous Operations:** Non-blocking, tasks can be executed in parallel or concurrently, and execution is often associated with callbacks, promises, or async/await mechanisms.
- **`Aync Await Syntax:`** async and await are features in JavaScript that make it easier to work with asynchronous code. An async function returns a promise and can use the await keyword to pause execution until an asynchronous task is done, making code look more like traditional synchronous code.
- **`Inquirer Librarie:`** Inquirer is a powerful Node.js library that simplifies the process of creating interactive command-line interfaces (CLIs). It provides a collection of prompts and utilities for easily gathering user input and building user-friendly command-line applications.
- **`Chalk Librarie:`** Chalk is a Node.js library for styling text in the terminal. It allows you to apply colors and formatting to the output text in your command-line applications, making them more visually appealing and easier to read.
- **`Further Learning:`** For more information, you can explore the [Inquirer documentation](https://www.npmjs.com/package/inquirer) and [Chalk documentation](https://www.npmjs.com/package/chalk).
- ### Online Recorded Sessions & videos üì∫:
  - Cjs & ES Modules: [Part 1](https://www.youtube.com/watch?v=RNkAHEyRk8A&t=154s) & [Part 2](https://www.youtube.com/watch?v=QqLO8wqlMf0)
  - [Asynchronous & Synchronous](https://www.youtube.com/watch?v=i7Ws2AkZDKg)
  - [Aync Await Syntax](https://youtu.be/bLre6Uf4Op0?list=PLu0W_9lII9ahR1blWXxgSlL4y9iQBnLpR)
- ### Assignments üìö:
  - **modular calculator:** Create a modular calculator program using TypeScript. The program should take user input through the Inquirer library and implement various arithmetic operations  (addition, subtraction, multiplication, division) as separate ES modules.
    - [Video Tutorial](https://www.youtube.com/watch?v=ifGvJlg4L0I)
    - [Solved Assignment](https://github.com/a-rehman-ujjan/PIAIC-Projects/tree/main/calculator)
  - **Quiz application:** Create a quiz application using TypeScript and the Inquirer library. The program should take user input through Inquirer, implement a quiz with a variable number of questions, calculate the quiz score in a separate ES module, and display the final result along with correct and incorrect user-given answers.
    - [Video Tutorial](https://www.youtube.com/watch?v=uPFKtQ8kIQk&t=776s)
- ## [Class 5 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-5)

# Class 6: Advanced TypeScript Concepts and Package Management

- **`TypeScript Unions:`** TypeScript unions allow you to define a variable or parameter that can hold values of multiple specified types. Unions are used to create more flexible and versatile data types, accommodating different data variations. A value assigned to a union type can be of any of the specified types.
- **`Type Literals:`** Type literals allow you to define exact values that a variable can hold. This is useful when you want to restrict a variable to only accept specific values.
- **`Type Aliases:`** Type aliases allow you to create custom names for types. This is helpful for making your code more readable and for simplifying complex type definitions, especially when unions are involved.
- **`TypeScript Objects:`** In TypeScript, an object is a data structure that holds key-value pairs. Keys are strings, and values can be of any type. Objects help organize related data, and you can access values using keys.
- **`NPM and Package Management:`** NPM (Node Package Manager) is a tool for managing and sharing JavaScript code. It helps you add, update, and remove packages (libraries) in your projects, making it easier to build and collaborate on software.
- ### Online Recorded Sessions & videos  üì∫:
  - [npm and Node.js Packages](https://youtu.be/nSFe1-kpfbQ?list=PLu0W_9lII9ahR1blWXxgSlL4y9iQBnLpR)
  - [Typescript Unions and Literals](https://www.youtube.com/watch?v=oZata4VXyRw)
  - [Type Aliases and Typescript Objects](https://www.youtube.com/watch?v=mCatIHCmems)
- ## Assignments üìö:
  - Publish your finished assignments from the previous class (Calculator & Quiz App) on [npmjs](https://www.npmjs.com/).
    - [How to Publish NPM Package?](https://www.youtube.com/watch?v=C56TrsGNgOk)
  - Verify the functionality of your package by installing it. Ensure that it runs properly in the command-line interface (CMD) without automatically opening the code file.
- ### [Class 6 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-6)

# Class 7: TypeScript Interfaces and Type Compatibility

In 7th class, we explored TypeScript interfaces, delving into the concepts of structural and nominal typing. We highlighted the distinctions between these approaches and their impact on type comparisons.

We then delved into the realm of "fresh" and "stale" objects in TypeScript.

- **`Interfaces in TypeScript:`** [Interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html) allows you to define the structure of objects, specifying what properties and methods an object of a particular type should have. They serve as a contract that enforces a consistent shape for objects that adhere to that interface, preventing errors if required properties or methods are missing. Interfaces encourage reusable code and allow extension, letting you inherit properties and methods from other interfaces for creating new ones.
- **`Type Compatibility:`** [Type compatibility](https://learntypescript.dev/04/l9-type-compatibility) in TypeScript refers to how the type system determines whether one type can be assigned to another without causing type errors. It involves checking the structure and properties of the types involved to ensure they match appropriately. TypeScript's type compatibility rules allow for more flexible code while maintaining type safety.

TypeScript utilizes structural typing to determine type compatibility. When two types possess compatible structures, they're deemed compatible, regardless of separate definitions or distinct names. For object assignments, if the target type contains all properties of the source type and potentially more, the assignment is permitted. Surplus properties in the source type aren't problematic, as long as the required ones match.

In function types, parameter compatibility is examined. If a function anticipates certain parameter types, a compatible function with identical parameter structures can be assigned, even with different parameter names. Types featuring optional properties or rest elements can coexist with types possessing equivalent properties, even if not explicitly labeled as optional or part of the rest. TypeScript frequently broadens literal types to their corresponding primitive types, influencing type compatibility.
- **`Structural Typing:`**  [Structural typing](https://www.typescriptlang.org/play#example/structural-typing) is based on the structure or shape of types. Two types are considered compatible if their structures match, even if they were defined independently, regardless of their names or where they were defined. Type names are not significant; only the structure matters.
- **`Nominal Typing:`** [Nominal typing](https://www.typescriptlang.org/play#example/nominal-typing) relies on the explicit names of types. Two types with the same structure but different names are not considered compatible, Even if two types have the same structure, they are not compatible if their names differ.

In many languages, including TypeScript, structural typing is the default approach. TypeScript uses structural typing to compare types and determine compatibility. This approach promotes code reusability and flexibility, as types that share the same structure are considered compatible, regardless of their names. However, there are scenarios where nominal typing might be preferred, especially when strong type separation is needed to prevent accidental type compatibility.

Understand the concept of "fresh" and "stale" objects in TypeScript, exploring how the language handles object immutability and mutability.

- **`Fresh & Stale Objects:`** To determine whether an object is fresh or stale, we examine its composition. If the object contains explicit key-value pairs defined directly on its right side, it is considered fresh. On the other hand, if the object references a previously defined object by its name, rather than having its own key-value pairs, it is deemed stale.
In TypeScript, a fresh object is one that is initialized with new key-value pairs on its right side, while a stale object is characterized by the act of assigning an object's name to another object, bypassing the use of distinct key-value pairs.
- **`Assigning Objects to Different Interfaces:`** To practically apply our knowledge, we created two interfaces: "Motorbike" and "Car". "Motorbike" had properties like model, mileage, and speed, while "Car" had properties "model" and "mileage". We then instantiated two objects, "BMW" using the "Car" interface and "H2R" using the "Motorbike" interface, Interestingly, attempting to assign "H2R" to "BMW" didn't raise errors. However, attempting the opposite ‚Äì "BMW" to "H2R" ‚Äì did trigger an error. This highlighted the concept of type compatibility. check Code of the class for example.
- ### [Class 7 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-7)
- ### Online Recorded Sessions & videos üì∫:
  - [Structural Typing](https://youtu.be/-BT-yObYthw?si=4VLF0EZtosPY9Sr1&t=56)
  - [Type Compatibility](https://youtu.be/-BT-yObYthw?si=-ZxQCPJWMSkTc5ve&t=610)
  - [Fresh & Stale Object](https://youtu.be/-BT-yObYthw?si=W-9gccEygp-ssd0u&t=1406)
- ## Assignments üìö:
  - `Modeling Online Store Entities` You're building a TypeScript application for an online store. Define the following types and interfaces:
    - Define an interface Product with properties like id, name, price, and category.
    - Create a type Cart that represents an array of Product objects.
    - Define an interface Customer with properties like id, name, and email.
    - Create a type Order that represents an object containing a Customer and a Cart.
    - Implement a function that calculates the total price of products in the cart.

  - `Building a Blog System` Imagine you're developing a TypeScript application for a blogging platform. Create the following types and interfaces:
    - Define an interface Author with properties like id, name, and bio.
    - Create a type Comment that represents an object with author (of type Author), content, and timestamp.
    - Define an interface Post with properties like id, title, content, author (of type Author), and an array of Comments.
    - Implement a function that sorts posts based on their number of comments.

  - `Social Media Platform` Develop a TypeScript application for a social media platform. Define the following types and interfaces:
    - Define an interface Profile with properties like id, username, bio, and an array of Posts.
    - Create a type Like that represents an object with user (of type User) and timestamp.
    - Define an interface Comment with properties like id, user (of type User), content, and timestamp.
    - Implement a function that finds the most liked post and the user who posted it


# Class 8: Advanced TypeScript Type Concepts

In today's class, we delved into advanced TypeScript type concepts, expanding our understanding of TypeScript's type system. We explored the following topics:

- **`Intersections in TypeScript:`** In TypeScript, [Intersections](https://www.typescripttutorial.net/typescript-tutorial/typescript-intersection-types/) are a way to combine multiple types into a single type definition. When you use intersections, you create a new type that contains all the properties and methods of the types you're intersecting.

- **`Type-Casting:`** [Type Casting](https://www.typescripttutorial.net/typescript-tutorial/type-casting/) in TypeScript, is a mechanism that allows you to tell the TypeScript compiler to treat a value as if it has a specific type, even if the compiler's type inference doesn't align with that type.

This can be necessary in situations where TypeScript cannot confidently determine the type of a value, but you, as the developer, know better. It's a way to override TypeScript's static type checking and inform the compiler about the intended type.

We discussed type-casting techniques, including type assertions and the 'as' keyword. These techniques enable type manipulation and conversions, providing flexibility when working with TypeScript types.

- **`Understanding "any," "unknown," and "never" Types:`**

  - **`"any" Type:`** The "any" type is the most flexible type in TypeScript. It essentially disables type checking for a particular variable or value, allowing it to hold values of any type. It is used when you don't know or care about the type of a value, or when working with dynamic data, such as user inputs or data from external sources. While "any" provides flexibility, it sacrifices type safety. Using "any" should be minimized in favor of more specific types whenever possible, as it can lead to runtime errors.

  - **`"unknown" Type:`** The "unknown" type is a safer alternative to "any." It represents values about which you have little or no information regarding their type. It is used when you need flexibility like "any" but want to ensure that you perform type checks or type assertions before performing operations on values of this type. "unknown" promotes type safety by forcing developers to make type assertions or perform checks before working with values of this type.

  - **`"never" Type:`** The "never" type represents values that should never occur. It is often used to indicate that a function will never return (i.e., it always throws an error or enters an infinite loop). It is used primarily in situations where the program cannot proceed normally, such as when an error is thrown, or in exhaustive type checking. "never" helps catch logical errors at compile time and is valuable in scenarios where certain code paths should never be reached.

These special types serve different purposes in TypeScript, and using them appropriately can improve type safety and maintainability in your code. It's generally advisable to use "any" sparingly and prefer "unknown" and "never" when you need more type safety and predictability in your TypeScript code.

These advanced type concepts enrich our knowledge of TypeScript's type system, equipping us to write more robust, expressive, and type-safe code. Understanding intersections and the characteristics of "any," "unknown," and "never" types empowers us to handle complex type scenarios with confidence.

- ### [Class 8 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-8)
- ### Online Recorded Sessions & videos üì∫:
  - [Intersection Type](https://youtu.be/5eNzid-34gQ)
  - [Type Casting](https://youtu.be/Qt-0TtD2W5o?si=ArzyxT3_XBFEHZSC&t=450)
  - [Any type](https://youtu.be/116T3KB_-Cs?si=7sY-fQYO0GvLqnuL&t=532), [Unknown Type](https://youtu.be/116T3KB_-Cs?si=Ro_QnozAU993DSBW&t=807), And [Never Type](https://youtu.be/116T3KB_-Cs?si=R7SxBmZ0s54whWx8&t=1131)

# Class 9: Enums, Arrays, Functions, and Async in TypeScript

Here's an overview of the Topics we covered:

- **`Enums in TypeScript:`** In TypeScript, an [enum](https://www.typescriptlang.org/docs/handbook/enums.html) (short for "enumeration") is a way to define a set of named constants, Enums can be useful in scenarios where you have a fixed set of options or when you want to improve code readability by using descriptive names instead of hardcoding numeric or string values. enum is like a list of predefined choices or options. It helps you use meaningful names instead of numbers or words to represent these choices, Enums make your code more readable and less error-prone when working with fixed sets of values.

  - **`Enums with var (Runtime-Generated Enum):`** When you declare an enum using var, TypeScript generates runtime code for the enum, This means that the enum is converted into actual JavaScript objects during the compilation process, and it exists in the runtime JavaScript code, It can be useful if you need the enum values to be accessible at runtime, for example, if you plan to use them in conditional logic that runs in the browser. Use `var` enums when you need to access enum values at runtime, for example, in scenarios involving user interactions or dynamic logic in the browser.
  - **`Enums with Const (Compile-Time Enum):`** When you declare an enum using const, TypeScript does not generate any runtime code for the enum, This enum is purely a compile-time construct, and its values are removed during the compilation process. It doesn't exist in the runtime JavaScript code, It is useful when you want to use enums for type checking and code clarity but don't need the enum values to be present in the generated JavaScript. Use `const` enums when you want type checking and code readability but don't want the enum values in the generated JavaScript, which can help reduce the size of the compiled code.

- **`Arrays:`** An [Array](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#arrays) is a data structure used to store a collection of values, where each value can be of the same or different types. Arrays are similar to arrays in JavaScript but come with the added benefit of type checking, allowing you to specify the types of elements that the array can contain.
-  **`Array Methods`**  Arrays come with a variety of built-in methods that make it easier to manipulate and work with array data. These methods are powerful tools for performing common operations on arrays. Here are some commonly used array methods in TypeScript:
    - **push():** Adds one or more elements to the end of an array.
    - **pop():** Removes the last element from an array and returns it.
    - **shift():** Removes the first element from an array and returns it.
    - **unshift():** Adds one or more elements to the beginning of an array.
    - **map():** Creates a new array by applying a function to each element of an existing array.
    - **filter():** Creates a new array containing all elements that pass a certain condition.
    - **reduce():** Applies a function to accumulate a single result from all elements of an array.
    - **forEach():** Iterates over each element in the array and executes a provided function.

These are just some of the most commonly used array methods in TypeScript. There are many [more](https://blog.canopas.com/typescript-array-methods-and-their-usages-daa8d498b4fd), each serving different purposes and providing powerful tools for working with arrays in your programs.


- **`Functions:`** We studied [functions](https://www.typescriptlang.org/docs/handbook/2/functions.html) as reusable blocks of code designed to perform specific tasks. Functions play a vital role in structuring code and enhancing reusability.
- **`Function Parameter Types:`**
    - **Required Parameters:** Required Parameters or Default Parameters are the standard parameters that you define when declaring a function, Required parameters must be provided when calling the function, and their absence results in a compile-time error.
    - **Optional Parameters:** Optional parameters are denoted by appending a `?` to the parameter name in the function declaration, They can be omitted when calling the function, and TypeScript doesn't enforce providing a value for them, The optional parameters always come at the end of the parameter list.
    - **Rest Parameters:** Rest parameters allow you to pass a variable number of arguments to a function as an array, They are denoted by three dots `...` followed by the parameter name, and there can be only one rest parameter in a function, Rest parameters collect all remaining arguments into an array, making it convenient to work with a variable number of inputs.


- **`Async in TypeScript:`** Async functions in JavaScript and TypeScript allow you to write code that appears to run in order, even when you're doing things that take time, like fetching data from the internet. You create an async function by adding the word `async` before `function`, An async function always returns a Promise. This Promise will either resolve to the value that the function explicitly returns or reject with an error.

These foundational topics are essential for a comprehensive understanding of TypeScript. They enable us to work effectively with data structures like enums and arrays, create flexible and reusable functions, and simplify asynchronous operations using `async` and `await`. Understanding these concepts is key to becoming proficient in TypeScript development.

- ### [How JS Works Behind The Scene -- Notes](https://drive.google.com/file/d/1ymdHpwzWIICZHO0pheRsxp2cXONwJmyU/view)
- ### [visualize How Callback and Event loop Works](https://wesbos.com/javascript/12-advanced-flow-control/66-the-event-loop-and-callback-hell)
- ### [Class 9 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-8)
- ### Online Recorded Sessions & videos üì∫:
  - [Enums](https://youtu.be/rzHjDTe-KWU?si=jDWSABONOfmlIffo&t=7)
  - Functions: [Part 1](https://www.youtube.com/watch?v=8yc2Yd8kJ_E) & [Part 2](https://www.youtube.com/watch?v=iRan4VCOy0A)
  - Array & Array Methods: [Part 1](https://www.youtube.com/watch?v=S7FfBHs-_BU), [Part 2](https://www.youtube.com/watch?v=ScuESgM3KWE) & [Part 3](https://www.youtube.com/watch?v=dCMt2lr5Hrs)
- ## Assignments üìö:
  - Create 2 functions, 2 with Required Parameters, 2 with Optional Parameters, And 2 With Rest Parameters.
  - Try creating Arrays with 12 different Array Methods.


# Class 10: Asynchronous Programming in TypeScript, callback functions and Promises

In the 10th class, we delved into asynchronous programming concepts in TypeScript, focusing on callback functions and Promises.

- **`Callbacks:`** A [callback](https://medium.com/@daanworks/what-is-a-callback-function-and-how-to-use-it-typescript-8b5834397e1d) is a function passed as an argument to another function, with the expectation that the receiving function will call it at a certain time, typically after some asynchronous operation or a time delay. Callbacks are commonly used in JavaScript and TypeScript to handle asynchronous tasks, such as making network requests, reading files, or responding to user interactions. Callbacks are crucial for managing tasks that may take time to complete.

- **`Callback Hell:`** [Callback hell](https://www.scaler.com/topics/callback-hell-in-javascript/), also known as the "Pyramid of Doom," is a term used to describe a situation in asynchronous programming when you have multiple nested callback functions. This occurs when you're working with deeply nested asynchronous operations, and each operation relies on the result of the previous one. Callback hell can make your code difficult to read, understand, and maintain due to the high level of indentation and complex control flow.

  - **`Inversion Of Control:`** Callback hell can also lead to an inversion of control problem. Inversion of control refers to a situation where the control flow of your program is inverted or managed by external systems or functions, rather than following a linear, top-down approach.

  - **Nasted Asynchronous Operations:** Asynchronous operations are nested within each other, leading to deeply indented code. This nesting makes it challenging to follow the logic, increases the risk of bugs, and reduces code maintainability.

  - **Inverted Control Flow:** Asynchronous callbacks are executed at a later time, often after multiple other functions have already been executed. This inversion of control can make it hard to reason about the sequence of operations in your code.

  - **Loss of Sequential Logic:** Your code's sequential logic is disrupted because it's split into separate callback functions. This can make it challenging to understand the order of execution.

  - **Error Handling Complexity:** Handling errors in deeply nested callbacks becomes complex, as you need to check for errors at multiple levels.

- **`Promises:`** To address callback hell and inversion of control, newer asynchronous patterns like Promises and async/await have been introduced. They provide more structured and readable ways to handle asynchronous code, avoiding the need for deeply nested callbacks. Promises, for example, allow you to chain asynchronous operations sequentially and async/await provides a more synchronous-looking syntax for handling asynchronous tasks, making code more linear and easier to manage.

  - **`Promises:`** [Promises](https://www.w3schools.com/js/js_promise.asp) in TypeScript (and JavaScript) are a way to handle asynchronous operations in a more structured and readable manner. A Promise represents a value that may not be available yet but will be resolved (fulfilled) with a value or rejected with a reason (usually an error). Promises provide a cleaner alternative to callback functions, especially for managing multiple asynchronous operations.

  - **Resolve and Reject:** Inside the Promise function, you have access to resolve and reject functions. You call resolve when the asynchronous operation is successful and reject when it fails.

- **`.then() and .catch():`** After creating a Promise, you can use the `.then()` method to specify what should happen when the Promise is resolved. You provide a callback function to .then() to handle the resolved value, And You can use the `.catch()` method to specify what should happen when the Promise is rejected. It allows you to handle errors that may occur during the Promise execution.

Promises provide a more organized way to work with asynchronous code, and .then() and .catch() make it easier to handle success and error scenarios. They have become the standard for handling asynchronous operations in modern TypeScript and JavaScript.

- ### [Class 10 Code](https://github.com/usmanashrf/typescript-batch48/blob/main/Evening-section/class-10)
- ### Online Recorded Sessions & videos üì∫:
  - [Callback Function](https://youtu.be/IJlGpI6l92U?si=vAR-1Eck4uu5_cJu&t=71)
  - [Callback Hell](https://youtu.be/fIPJUteOdLc?si=PgDzPI8_u_LLiDvD&t=22)
  - [Promises](https://youtu.be/Dadlf6YsTHA?si=tyqSRsK6_AnueZNJ&t=33)
  - [.then & .catch](https://youtu.be/Fsv4IEH-4Lw?si=NxxednCOaLL_048K&t=86)
- ## Assignments üìö:
  - Convert All Callback functions written in Class Code into Promises.

Remember, each class builds on the previous ones, deepening your understanding of TypeScript and web development concepts. For detailed information about each topic, refer to the provided [class slides](https://docs.google.com/presentation/d/1-7Kb3laJjJ68mOTF9v0fHImk5vTol0CeE43Sg8hoUXQ/mobilepresent#slide=id.gcb9a0b074_1_0).

Feel free to explore the topics further through online resources, video tutorials, and hands-on practice. Happy learning!


