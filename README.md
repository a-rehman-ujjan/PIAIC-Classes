Welcome to the PIAIC (AI, Web3, and Blockchain Development) Learning Journey! This README provides an overview of the topics covered in each class.

üìö **Note:** This README is a work in progress. As more classes are covered, I will continue updating the file with detailed summaries, topics, and assignments. Stay tuned for comprehensive insights into TypeScript and web development concepts!

# Repo Map üó∫Ô∏è
### [``` Typescript ```]()
### [``` Next.Js ```]()

# Typescript.
- [**Class 1: Introduction to TypeScript, Web Concepts, Next.js and Serverless Technology**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-1-introduction-to-typescript-and-web-concepts)
- [**Class 2: TypeScript Fundamentals, Variables, Primitive Data Types, Template Literals and Operators In Typescript**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-2-typescript-fundamentals)
- [**Class 3: Functions, Arrays, and User Input**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-3-functions-arrays-and-user-input)
- [**Class 4: Return Type Annotations, Arrow Function, Conditional Statements, and Loops**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-4-conditional-statements-and-loops)
- [**Class 5: CommonJS Modules vs. ECMA Modules, Asynchronous vs. Synchronous Operations, Aync Await Syntax, Inquirer and Chalk Librarie**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-5-modules-and-asynchronous-operations)
- [**Class 6: Typescript Unions, Aliases, Type literals, TypeScript Objects, and NPM**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-6-advanced-typescript-concepts-and-package-management)
- [**Class 7: Interfaces, Type Compatibility, Structural & Nominal Typing, and Fresh & Stale Objects**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-7-typescript-interfaces-and-type-compatibility)
- [**Class 8: Intersections in TypeScript, Type-Casting, "any," "unknown," and "never" Types**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-8-advanced-typescript-type-concepts)
- [**Class 9: Enums, Arrays, Functions, and Async in TypeScript**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-9-enums-arrays-functions-and-async-in-typescript)
- [**Class 10: Asynchronous Programming in TypeScript, callback functions, and Promises**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-10-asynchronous-programming-in-typeScript-callback-functions-and-promises)
- [**Class 11: Function Overloading, Tuples, Class Structural Typing, Inheritance, Constructors, and Access Modifiers**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-11-function-overloading-tuples-class-structural-typing-inheritance-constructors-and-access-modifiers-in-typeScript)

## Getting Started Resources ‚öôÔ∏è
### [Typescript Slides](https://docs.google.com/presentation/d/1-7Kb3laJjJ68mOTF9v0fHImk5vTol0CeE43Sg8hoUXQ/mobilepresent?slide=id.gcb9a0b074_1_0)
### [Getting Started Exercises](https://github.com/panaverse/typescript-node-projects/blob/main/getting-started-exercises.md)
### [Advanced Typescript Step-By-Step](https://github.com/panaverse/learn-typescript)
### [Node Projects](https://github.com/panaverse/learn-typescript/tree/master/NODE_PROJECTS)

# Class 1: Introduction to TypeScript and Web Concepts

- **`TypeScript Introduction:`** [TypeScript](https://www.typescriptlang.org/) is a programming language that builds upon JavaScript by adding static type-checking and other features. It enhances code quality and helps catch errors early in development.
- **`Web Concepts:`** Understand the evolution from Web 1.0 to Web 2.0 to Web 3.0: These terms refer to different stages in the evolution of the World Wide Web. Web 1.0 was the static web of early days, Web 2.0 brought interactive and social elements, and Web 3.0 aims to create a more intelligent, decentralized web.
- **`Introduction to Next.js:`**  Next.js is a popular React framework for building web applications. It enhances React with features like server-side rendering and routing.
- **`Serverless Technology:`** [Serverless computing](https://www.cloudflare.com/learning/serverless/what-is-serverless/) allows developers to focus on writing code without managing server infrastructure. It automatically scales based on demand.
- ## Assignments üìö:
  - Install development tools and console log "Hello, World!" using TypeScript.
- ### [Class 1 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-1)

# Class 2: TypeScript Fundamentals

- **`Programming Environment Setup:`** Configure [`Node.js`](https://nodejs.org/en), [`Visual Studio Code`](https://code.visualstudio.com/), and [`TypeScript`](https://www.typescriptlang.org/download) to create a development environment.
- **`Variables In Typescript:`**  A Variable is a named container or storage location that holds a value. It's used to store and manage data that a program needs to work with. In TypeScript variables are used to store different types of values, such as numbers, strings, objects, arrays, and more To use them, declare with `let`, `const`, or `var`, assign values, and manipulate as needed
- **`Primitive Data Types:`** Explore string, number, boolean, undefined, Symbol, BigInt, and null types.
- **`Template Literals:`**  Creating strings with embedded expressions for easier concatenation and formatting.
- **`Operators In Typescript:`** Using arithmetic, assignment, comparison, and logical operators to manipulate values.
- ### Online Recorded Sessions & videos üì∫:
  - [Operators](https://www.youtube.com/watch?v=wxS7j9q0nyc)
  - [Template Literals](https://www.youtube.com/watch?v=PFzeMUojeQY&t=80s&pp=ygUadGVtcGxhdGUgbGl0ZXJhbHMgaW4gaGluZGk%3D)
  - [Primitive Data Types](https://youtu.be/qpU3WIqRz9I?list=PLu0W_9lII9ahR1blWXxgSlL4y9iQBnLpR)
  - [Variables (let, var & const)](https://www.youtube.com/watch?v=Icev9Oxf0WA&list=PLu0W_9lII9ahR1blWXxgSlL4y9iQBnLpR&index=3&pp=iAQB)
- ## Assignments üìö:
  - Complete assignments related to variables, types, and operators.
- ### [Class 2 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-2)

# Class 3: Functions, Arrays, and User Input

- **`Prompt Library:`** Learn how to take user input using the [Prompt library](https://www.npmjs.com/package/prompt).
- **`Functions in TypeScript:`** Functions in TypeScript are named code blocks used to encapsulate and reuse sets of instructions, enhancing code organization and maintainability.
- **`Array in TypeScript:`** Arrays in TypeScript are data structures that allow you to store collections of values of the same or different types. They are a fundamental part of programming and are used to manage lists of items efficiently. 
- ### Online Recorded Sessions & videos üì∫:
  - Functions: [Part 1](https://www.youtube.com/watch?v=8yc2Yd8kJ_E) & [Part 2](https://www.youtube.com/watch?v=iRan4VCOy0A)
  - Array & Array Methods: [Part 1](https://www.youtube.com/watch?v=S7FfBHs-_BU), [Part 2](https://www.youtube.com/watch?v=ScuESgM3KWE) & [Part 3](https://www.youtube.com/watch?v=dCMt2lr5Hrs)
- ## Assignments üìö:
  - **Building a grading system:** Assigned students to build a grading system using user input and conditional statements.
  - **User input handling with Prompt:** Practically implemented user input capture using Prompt.
- ### [Class 3 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-3)

# Class 4: Conditional Statements and Loops

- **`Return Type Annotations:`** A return [type annotation](https://www.tektutorialshub.com/typescript/type-annotation-in-typescript/) in TypeScript specifies the type of value that a function will provide as its output. It helps clarify what the function returns and catches type-related errors.
- **`Arrow Function:`** An arrow function is a more concise way to define functions in JavaScript and TypeScript. It provides a shorter syntax compared to traditional function expressions. Arrow functions were introduced in ECMAScript 6 (ES6) and have become a popular choice for writing functions in modern JavaScript and TypeScript code.
- **`Conditional Statements:`** Conditional statements are programming constructs that allow you to make decisions in your code based on certain conditions. They control the flow of your program by executing different blocks of code depending on whether a specified condition is true or false.
- **`Nested Statements:`** Nested statements are programming constructs where one or more statements are placed within another statement's block of code. We use nested statements to build more complex logic and implement decision-making processes that involve multiple levels of conditions.
- **`For Loops:`** A "for loop" is a programming construct that allows you to repetitively execute a block of code for a predetermined number of iterations. It consists of three main components: initialization, a condition, and an iteration statement.
- ### Online Recorded Sessions & videos üì∫:
  - [Arrow Function](https://www.youtube.com/watch?v=44aVMRtxKyc)
  - Conditional Statements: [Part 1](https://www.youtube.com/watch?v=MrRJqVtxETs) & [Part 2](https://www.youtube.com/watch?v=bGjWAbMfkNE)
  - [Loops](https://www.youtube.com/watch?v=QsaHgcjPqH8)
- ## Assignments üìö:
  - Solve assignments related to implementing conditional statements and loops. ([Example](https://github.com/usmanashrf/typescript-batch48/blob/main/Morning-section/class-4/index.ts))
- ### [Class 4 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-4)

# Class 5: Modules and Asynchronous Operations

- **`CommonJS Modules vs. ECMA Modules:`** Difference between CommonJS and ECMAScript modules lies in their syntax, loading mechanisms, and compatibility with different environments. While CommonJS is commonly used in Node.js and follows a synchronous approach, ECMAScript modules are used both in browsers and Node.js, and they use asynchronous loading with a more structured syntax.
- **`Asynchronous vs. Synchronous Operations:`**
  - **Synchronous Operations:** Blocking, sequential execution, and tasks are completed in a specific order. Execution follows a single-threaded approach.
  - **Asynchronous Operations:** Non-blocking, tasks can be executed in parallel or concurrently, and execution is often associated with callbacks, promises, or async/await mechanisms.
- **`Aync Await Syntax:`** async and await are features in JavaScript that make it easier to work with asynchronous code. An async function returns a promise and can use the await keyword to pause execution until an asynchronous task is done, making code look more like traditional synchronous code.
- **`Inquirer Librarie:`** Inquirer is a powerful Node.js library that simplifies the process of creating interactive command-line interfaces (CLIs). It provides a collection of prompts and utilities for easily gathering user input and building user-friendly command-line applications.
- **`Chalk Librarie:`** Chalk is a Node.js library for styling text in the terminal. It allows you to apply colors and formatting to the output text in your command-line applications, making them more visually appealing and easier to read.
- **`Further Learning:`** For more information, you can explore the [Inquirer documentation](https://www.npmjs.com/package/inquirer) and [Chalk documentation](https://www.npmjs.com/package/chalk).
- ### Online Recorded Sessions & videos üì∫:
  - Cjs & ES Modules: [Part 1](https://www.youtube.com/watch?v=RNkAHEyRk8A&t=154s) & [Part 2](https://www.youtube.com/watch?v=QqLO8wqlMf0)
  - [Asynchronous & Synchronous](https://www.youtube.com/watch?v=i7Ws2AkZDKg)
  - [Aync Await Syntax](https://youtu.be/bLre6Uf4Op0?list=PLu0W_9lII9ahR1blWXxgSlL4y9iQBnLpR)
- ### Assignments üìö:
  - **modular calculator:** Create a modular calculator program using TypeScript. The program should take user input through the Inquirer library and implement various arithmetic operations  (addition, subtraction, multiplication, division) as separate ES modules.
    - [Video Tutorial](https://www.youtube.com/watch?v=ifGvJlg4L0I)
    - [Solved Assignment](https://github.com/a-rehman-ujjan/PIAIC-Projects/tree/main/calculator)
  - **Quiz application:** Create a quiz application using TypeScript and the Inquirer library. The program should take user input through Inquirer, implement a quiz with a variable number of questions, calculate the quiz score in a separate ES module, and display the final result along with correct and incorrect user-given answers.
    - [Video Tutorial](https://www.youtube.com/watch?v=uPFKtQ8kIQk&t=776s)
- ## [Class 5 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-5)

# Class 6: Advanced TypeScript Concepts and Package Management

- **`TypeScript Unions:`** TypeScript unions allow you to define a variable or parameter that can hold values of multiple specified types. Unions are used to create more flexible and versatile data types, accommodating different data variations. A value assigned to a union type can be of any of the specified types.
- **`Type Literals:`** Type literals allow you to define exact values that a variable can hold. This is useful when you want to restrict a variable to only accept specific values.
- **`Type Aliases:`** Type aliases allow you to create custom names for types. This is helpful for making your code more readable and for simplifying complex type definitions, especially when unions are involved.
- **`TypeScript Objects:`** In TypeScript, an object is a data structure that holds key-value pairs. Keys are strings, and values can be of any type. Objects help organize related data, and you can access values using keys.
- **`NPM and Package Management:`** NPM (Node Package Manager) is a tool for managing and sharing JavaScript code. It helps you add, update, and remove packages (libraries) in your projects, making it easier to build and collaborate on software.
- ### Online Recorded Sessions & videos  üì∫:
  - [npm and Node.js Packages](https://youtu.be/nSFe1-kpfbQ?list=PLu0W_9lII9ahR1blWXxgSlL4y9iQBnLpR)
  - [Typescript Unions and Literals](https://www.youtube.com/watch?v=oZata4VXyRw)
  - [Type Aliases and Typescript Objects](https://www.youtube.com/watch?v=mCatIHCmems)
- ## Assignments üìö:
  - Publish your finished assignments from the previous class (Calculator & Quiz App) on [npmjs](https://www.npmjs.com/).
    - [How to Publish NPM Package?](https://www.youtube.com/watch?v=C56TrsGNgOk)
  - Verify the functionality of your package by installing it. Ensure that it runs properly in the command-line interface (CMD) without automatically opening the code file.
- ### [Class 6 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-6)

# Class 7: TypeScript Interfaces and Type Compatibility

In 7th class, we explored TypeScript interfaces, delving into the concepts of structural and nominal typing. We highlighted the distinctions between these approaches and their impact on type comparisons.

We then delved into the realm of "fresh" and "stale" objects in TypeScript.

- **`Interfaces in TypeScript:`** [Interfaces](https://www.typescriptlang.org/docs/handbook/interfaces.html) allows you to define the structure of objects, specifying what properties and methods an object of a particular type should have. They serve as a contract that enforces a consistent shape for objects that adhere to that interface, preventing errors if required properties or methods are missing. Interfaces encourage reusable code and allow extension, letting you inherit properties and methods from other interfaces for creating new ones.
- **`Type Compatibility:`** [Type compatibility](https://learntypescript.dev/04/l9-type-compatibility) in TypeScript refers to how the type system determines whether one type can be assigned to another without causing type errors. It involves checking the structure and properties of the types involved to ensure they match appropriately. TypeScript's type compatibility rules allow for more flexible code while maintaining type safety.

TypeScript utilizes structural typing to determine type compatibility. When two types possess compatible structures, they're deemed compatible, regardless of separate definitions or distinct names. For object assignments, if the target type contains all properties of the source type and potentially more, the assignment is permitted. Surplus properties in the source type aren't problematic, as long as the required ones match.

In function types, parameter compatibility is examined. If a function anticipates certain parameter types, a compatible function with identical parameter structures can be assigned, even with different parameter names. Types featuring optional properties or rest elements can coexist with types possessing equivalent properties, even if not explicitly labeled as optional or part of the rest. TypeScript frequently broadens literal types to their corresponding primitive types, influencing type compatibility.
- **`Structural Typing:`**  [Structural typing](https://www.typescriptlang.org/play#example/structural-typing) is based on the structure or shape of types. Two types are considered compatible if their structures match, even if they were defined independently, regardless of their names or where they were defined. Type names are not significant; only the structure matters.
- **`Nominal Typing:`** [Nominal typing](https://www.typescriptlang.org/play#example/nominal-typing) relies on the explicit names of types. Two types with the same structure but different names are not considered compatible, Even if two types have the same structure, they are not compatible if their names differ.

In many languages, including TypeScript, structural typing is the default approach. TypeScript uses structural typing to compare types and determine compatibility. This approach promotes code reusability and flexibility, as types that share the same structure are considered compatible, regardless of their names. However, there are scenarios where nominal typing might be preferred, especially when strong type separation is needed to prevent accidental type compatibility.

Understand the concept of "fresh" and "stale" objects in TypeScript, exploring how the language handles object immutability and mutability.

- **`Fresh & Stale Objects:`** To determine whether an object is fresh or stale, we examine its composition. If the object contains explicit key-value pairs defined directly on its right side, it is considered fresh. On the other hand, if the object references a previously defined object by its name, rather than having its own key-value pairs, it is deemed stale.
In TypeScript, a fresh object is one that is initialized with new key-value pairs on its right side, while a stale object is characterized by the act of assigning an object's name to another object, bypassing the use of distinct key-value pairs.
- **`Assigning Objects to Different Interfaces:`** To practically apply our knowledge, we created two interfaces: "Motorbike" and "Car". "Motorbike" had properties like model, mileage, and speed, while "Car" had properties "model" and "mileage". We then instantiated two objects, "BMW" using the "Car" interface and "H2R" using the "Motorbike" interface, Interestingly, attempting to assign "H2R" to "BMW" didn't raise errors. However, attempting the opposite ‚Äì "BMW" to "H2R" ‚Äì did trigger an error. This highlighted the concept of type compatibility. check Code of the class for example.
- ### [Class 7 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-7)
- ### Online Recorded Sessions & videos üì∫:
  - [Structural Typing](https://youtu.be/-BT-yObYthw?si=4VLF0EZtosPY9Sr1&t=56)
  - [Type Compatibility](https://youtu.be/-BT-yObYthw?si=-ZxQCPJWMSkTc5ve&t=610)
  - [Fresh & Stale Object](https://youtu.be/-BT-yObYthw?si=W-9gccEygp-ssd0u&t=1406)
- ## Assignments üìö:
  - `Modeling Online Store Entities` You're building a TypeScript application for an online store. Define the following types and interfaces:
    - Define an interface Product with properties like id, name, price, and category.
    - Create a type Cart that represents an array of Product objects.
    - Define an interface Customer with properties like id, name, and email.
    - Create a type Order that represents an object containing a Customer and a Cart.
    - Implement a function that calculates the total price of products in the cart.

  - `Building a Blog System` Imagine you're developing a TypeScript application for a blogging platform. Create the following types and interfaces:
    - Define an interface Author with properties like id, name, and bio.
    - Create a type Comment that represents an object with author (of type Author), content, and timestamp.
    - Define an interface Post with properties like id, title, content, author (of type Author), and an array of Comments.
    - Implement a function that sorts posts based on their number of comments.

  - `Social Media Platform` Develop a TypeScript application for a social media platform. Define the following types and interfaces:
    - Define an interface Profile with properties like id, username, bio, and an array of Posts.
    - Create a type Like that represents an object with user (of type User) and timestamp.
    - Define an interface Comment with properties like id, user (of type User), content, and timestamp.
    - Implement a function that finds the most liked post and the user who posted it


# Class 8: Advanced TypeScript Type Concepts

In today's class, we delved into advanced TypeScript type concepts, expanding our understanding of TypeScript's type system. We explored the following topics:

- **`Intersections in TypeScript:`** In TypeScript, [Intersections](https://www.typescripttutorial.net/typescript-tutorial/typescript-intersection-types/) are a way to combine multiple types into a single type definition. When you use intersections, you create a new type that contains all the properties and methods of the types you're intersecting.

- **`Type-Casting:`** [Type Casting](https://www.typescripttutorial.net/typescript-tutorial/type-casting/) in TypeScript, is a mechanism that allows you to tell the TypeScript compiler to treat a value as if it has a specific type, even if the compiler's type inference doesn't align with that type.

This can be necessary in situations where TypeScript cannot confidently determine the type of a value, but you, as the developer, know better. It's a way to override TypeScript's static type checking and inform the compiler about the intended type.

We discussed type-casting techniques, including type assertions and the 'as' keyword. These techniques enable type manipulation and conversions, providing flexibility when working with TypeScript types.

- **`Understanding "any," "unknown," and "never" Types:`**

  - **`"any" Type:`** The "any" type is the most flexible type in TypeScript. It essentially disables type checking for a particular variable or value, allowing it to hold values of any type. It is used when you don't know or care about the type of a value, or when working with dynamic data, such as user inputs or data from external sources. While "any" provides flexibility, it sacrifices type safety. Using "any" should be minimized in favor of more specific types whenever possible, as it can lead to runtime errors.

  - **`"unknown" Type:`** The "unknown" type is a safer alternative to "any." It represents values about which you have little or no information regarding their type. It is used when you need flexibility like "any" but want to ensure that you perform type checks or type assertions before performing operations on values of this type. "unknown" promotes type safety by forcing developers to make type assertions or perform checks before working with values of this type.

  - **`"never" Type:`** The "never" type represents values that should never occur. It is often used to indicate that a function will never return (i.e., it always throws an error or enters an infinite loop). It is used primarily in situations where the program cannot proceed normally, such as when an error is thrown, or in exhaustive type checking. "never" helps catch logical errors at compile time and is valuable in scenarios where certain code paths should never be reached.

These special types serve different purposes in TypeScript, and using them appropriately can improve type safety and maintainability in your code. It's generally advisable to use "any" sparingly and prefer "unknown" and "never" when you need more type safety and predictability in your TypeScript code.

These advanced type concepts enrich our knowledge of TypeScript's type system, equipping us to write more robust, expressive, and type-safe code. Understanding intersections and the characteristics of "any," "unknown," and "never" types empowers us to handle complex type scenarios with confidence.

- ### [Class 8 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-8)
- ### Online Recorded Sessions & videos üì∫:
  - [Intersection Type](https://youtu.be/5eNzid-34gQ)
  - [Type Casting](https://youtu.be/Qt-0TtD2W5o?si=ArzyxT3_XBFEHZSC&t=450)
  - [Any type](https://youtu.be/116T3KB_-Cs?si=7sY-fQYO0GvLqnuL&t=532), [Unknown Type](https://youtu.be/116T3KB_-Cs?si=Ro_QnozAU993DSBW&t=807), And [Never Type](https://youtu.be/116T3KB_-Cs?si=R7SxBmZ0s54whWx8&t=1131)

# Class 9: Enums, Arrays, Functions, and Async in TypeScript

Here's an overview of the Topics we covered:

- **`Enums in TypeScript:`** In TypeScript, an [enum](https://www.typescriptlang.org/docs/handbook/enums.html) (short for "enumeration") is a way to define a set of named constants, Enums can be useful in scenarios where you have a fixed set of options or when you want to improve code readability by using descriptive names instead of hardcoding numeric or string values. enum is like a list of predefined choices or options. It helps you use meaningful names instead of numbers or words to represent these choices, Enums make your code more readable and less error-prone when working with fixed sets of values.

  - **`Enums with var (Runtime-Generated Enum):`** When you declare an enum using var, TypeScript generates runtime code for the enum, This means that the enum is converted into actual JavaScript objects during the compilation process, and it exists in the runtime JavaScript code, It can be useful if you need the enum values to be accessible at runtime, for example, if you plan to use them in conditional logic that runs in the browser. Use `var` enums when you need to access enum values at runtime, for example, in scenarios involving user interactions or dynamic logic in the browser.
  - **`Enums with Const (Compile-Time Enum):`** When you declare an enum using const, TypeScript does not generate any runtime code for the enum, This enum is purely a compile-time construct, and its values are removed during the compilation process. It doesn't exist in the runtime JavaScript code, It is useful when you want to use enums for type checking and code clarity but don't need the enum values to be present in the generated JavaScript. Use `const` enums when you want type checking and code readability but don't want the enum values in the generated JavaScript, which can help reduce the size of the compiled code.

- **`Arrays:`** An [Array](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#arrays) is a data structure used to store a collection of values, where each value can be of the same or different types. Arrays are similar to arrays in JavaScript but come with the added benefit of type checking, allowing you to specify the types of elements that the array can contain.
-  **`Array Methods`**  Arrays come with a variety of built-in methods that make it easier to manipulate and work with array data. These methods are powerful tools for performing common operations on arrays. Here are some commonly used array methods in TypeScript:
    - **push():** Adds one or more elements to the end of an array.
    - **pop():** Removes the last element from an array and returns it.
    - **shift():** Removes the first element from an array and returns it.
    - **unshift():** Adds one or more elements to the beginning of an array.
    - **map():** Creates a new array by applying a function to each element of an existing array.
    - **filter():** Creates a new array containing all elements that pass a certain condition.
    - **reduce():** Applies a function to accumulate a single result from all elements of an array.
    - **forEach():** Iterates over each element in the array and executes a provided function.

These are just some of the most commonly used array methods in TypeScript. There are many [more](https://blog.canopas.com/typescript-array-methods-and-their-usages-daa8d498b4fd), each serving different purposes and providing powerful tools for working with arrays in your programs.


- **`Functions:`** We studied [functions](https://www.typescriptlang.org/docs/handbook/2/functions.html) as reusable blocks of code designed to perform specific tasks. Functions play a vital role in structuring code and enhancing reusability.
- **`Function Parameter Types:`**
    - **Required Parameters:** Required Parameters or Default Parameters are the standard parameters that you define when declaring a function, Required parameters must be provided when calling the function, and their absence results in a compile-time error.
    - **Optional Parameters:** Optional parameters are denoted by appending a `?` to the parameter name in the function declaration, They can be omitted when calling the function, and TypeScript doesn't enforce providing a value for them, The optional parameters always come at the end of the parameter list.
    - **Rest Parameters:** Rest parameters allow you to pass a variable number of arguments to a function as an array, They are denoted by three dots `...` followed by the parameter name, and there can be only one rest parameter in a function, Rest parameters collect all remaining arguments into an array, making it convenient to work with a variable number of inputs.


- **`Async in TypeScript:`** Async functions in JavaScript and TypeScript allow you to write code that appears to run in order, even when you're doing things that take time, like fetching data from the internet. You create an async function by adding the word `async` before `function`, An async function always returns a Promise. This Promise will either resolve to the value that the function explicitly returns or reject with an error.

These foundational topics are essential for a comprehensive understanding of TypeScript. They enable us to work effectively with data structures like enums and arrays, create flexible and reusable functions, and simplify asynchronous operations using `async` and `await`. Understanding these concepts is key to becoming proficient in TypeScript development.

- ### [How JS Works Behind The Scene -- Notes](https://drive.google.com/file/d/1ymdHpwzWIICZHO0pheRsxp2cXONwJmyU/view)
- ### [visualize How Callback and Event loop Works](https://wesbos.com/javascript/12-advanced-flow-control/66-the-event-loop-and-callback-hell)
- ### [Class 9 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Morning-section/class-8)
- ### Online Recorded Sessions & videos üì∫:
  - [Enums](https://youtu.be/rzHjDTe-KWU?si=jDWSABONOfmlIffo&t=7)
  - Functions: [Part 1](https://www.youtube.com/watch?v=8yc2Yd8kJ_E) & [Part 2](https://www.youtube.com/watch?v=iRan4VCOy0A)
  - Array & Array Methods: [Part 1](https://www.youtube.com/watch?v=S7FfBHs-_BU), [Part 2](https://www.youtube.com/watch?v=ScuESgM3KWE) & [Part 3](https://www.youtube.com/watch?v=dCMt2lr5Hrs)
- ## Assignments üìö:
  - Create 2 functions, 2 with Required Parameters, 2 with Optional Parameters, And 2 With Rest Parameters.
  - Try creating Arrays with 12 different Array Methods.


# Class 10: Asynchronous Programming in TypeScript, callback functions and Promises

In the 10th class, we delved into asynchronous programming concepts in TypeScript, focusing on callback functions and Promises.

- **`Callbacks:`** A [callback](https://medium.com/@daanworks/what-is-a-callback-function-and-how-to-use-it-typescript-8b5834397e1d) is a function passed as an argument to another function, with the expectation that the receiving function will call it at a certain time, typically after some asynchronous operation or a time delay. Callbacks are commonly used in JavaScript and TypeScript to handle asynchronous tasks, such as making network requests, reading files, or responding to user interactions. Callbacks are crucial for managing tasks that may take time to complete.

- **`Callback Hell:`** [Callback hell](https://www.scaler.com/topics/callback-hell-in-javascript/), also known as the "Pyramid of Doom," is a term used to describe a situation in asynchronous programming when you have multiple nested callback functions. This occurs when you're working with deeply nested asynchronous operations, and each operation relies on the result of the previous one. Callback hell can make your code difficult to read, understand, and maintain due to the high level of indentation and complex control flow.

  - **`Inversion Of Control:`** Callback hell can also lead to an inversion of control problem. Inversion of control refers to a situation where the control flow of your program is inverted or managed by external systems or functions, rather than following a linear, top-down approach.

  - **Nasted Asynchronous Operations:** Asynchronous operations are nested within each other, leading to deeply indented code. This nesting makes it challenging to follow the logic, increases the risk of bugs, and reduces code maintainability.

  - **Inverted Control Flow:** Asynchronous callbacks are executed at a later time, often after multiple other functions have already been executed. This inversion of control can make it hard to reason about the sequence of operations in your code.

  - **Loss of Sequential Logic:** Your code's sequential logic is disrupted because it's split into separate callback functions. This can make it challenging to understand the order of execution.

  - **Error Handling Complexity:** Handling errors in deeply nested callbacks becomes complex, as you need to check for errors at multiple levels.

- **`Promises:`** To address callback hell and inversion of control, newer asynchronous patterns like Promises and async/await have been introduced. They provide more structured and readable ways to handle asynchronous code, avoiding the need for deeply nested callbacks. Promises, for example, allow you to chain asynchronous operations sequentially and async/await provides a more synchronous-looking syntax for handling asynchronous tasks, making code more linear and easier to manage.

  - **`Promises:`** [Promises](https://www.w3schools.com/js/js_promise.asp) in TypeScript (and JavaScript) are a way to handle asynchronous operations in a more structured and readable manner. A Promise represents a value that may not be available yet but will be resolved (fulfilled) with a value or rejected with a reason (usually an error). Promises provide a cleaner alternative to callback functions, especially for managing multiple asynchronous operations.

  - **Resolve and Reject:** Inside the Promise function, you have access to resolve and reject functions. You call resolve when the asynchronous operation is successful and reject when it fails.

- **`.then() and .catch():`** After creating a Promise, you can use the `.then()` method to specify what should happen when the Promise is resolved. You provide a callback function to .then() to handle the resolved value, And You can use the `.catch()` method to specify what should happen when the Promise is rejected. It allows you to handle errors that may occur during the Promise execution.

Promises provide a more organized way to work with asynchronous code, and .then() and .catch() make it easier to handle success and error scenarios. They have become the standard for handling asynchronous operations in modern TypeScript and JavaScript.

- ### [Class 10 Code](https://github.com/usmanashrf/typescript-batch48/blob/main/Evening-section/class-10)
- ### Online Recorded Sessions & videos üì∫:
  - [Callback Function](https://youtu.be/IJlGpI6l92U?si=vAR-1Eck4uu5_cJu&t=71)
  - [Callback Hell](https://youtu.be/fIPJUteOdLc?si=PgDzPI8_u_LLiDvD&t=22)
  - [Promises](https://youtu.be/Dadlf6YsTHA?si=tyqSRsK6_AnueZNJ&t=33)
  - [.then & .catch](https://youtu.be/Fsv4IEH-4Lw?si=NxxednCOaLL_048K&t=86)
- ## Assignments üìö:
  - Convert All Callback functions written in Class Code into Promises. [**Solved Example**](https://github.com/Azeem000011111111/New-folder--9-/blob/main/index.ts)

# Class 11: Function Overloading, Tuples, Class Structural Typing, Inheritance, Constructors, and Access Modifiers in TypeScript

In the 11th class, we delved into several essential concepts for building robust object-oriented programs in TypeScript. Here's a summary of what we covered:

- **`Function Overloading:`** [function overloading](https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads) is a feature that allows you to define multiple function signatures for a single function name. TypeScript uses the number and types of function parameters to determine which function implementation to call. It's useful when you want to provide different ways to call a function based on the provided arguments.
  - **Function Signatures:** A Function Signature refers to the declaration or definition of a function, including its name, parameter types, and return type. It specifies the structure and types of the function's arguments and its return value. Function signatures are used for type checking and to define how a function can be called and what it should return. A function signature typically includes **Function Name**, **Parameter Types**, And **Return Type** like: `function name(a: number, b: number): number {}`

- **`Tuples:`** [tuples](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#tuple) is a type in TypeScript that enables you to create ordered arrays with a fixed number of elements, each of which may have a different data type. Tuples are similar to arrays but provide specific type checking for each element at a specified position. For example, you can create a tuple to represent a point in 2D space with coordinates (x, y).

- **`Classes:`** classes are a fundamental feature that allows you to define blueprints for objects. They provide a way to create object-oriented programming constructs by encapsulating data (properties) and behavior (methods) into a single unit. Classes serve as templates for creating instances (objects) that share the same structure and behavior.

- **`Class Structural Typing:`** TypeScript uses [structural typing](https://www.typescriptlang.org/docs/handbook/2/classes.html#structural-typing) to determine if two classes are compatible based on their structure (the shape of their properties and methods) rather than explicit inheritance. This means that if two classes have the same structure, they are considered compatible, even if they don't share a common parent class or interface.

- **`Inheritance:`** [Inheritance](https://www.typescriptlang.org/docs/handbook/2/classes.html#inheritance), Classes can inherit properties and methods from other classes using the `extends` keyword. Inheritance allows for creating a hierarchy of classes, where a subclass inherits the characteristics of its superclass.

- **`Constructors:`** [Constructors](https://www.typescriptlang.org/docs/handbook/2/classes.html#constructors) are special methods within a class that are automatically called when an instance (object) of the class is created using the `new` keyword. Constructors are used to initialize the object's properties, set up initial values, and perform any other necessary setup operations. Inside the constructor, you can assign values to the object's properties based on the provided arguments or set default values. Constructors are implicitly invoked when you create an object from the class using the `new` keyword. The constructor is called before the object is returned. A class can have only one constructor. Overloading constructors (having multiple constructors with different parameter lists) is not supported in TypeScript. However, you can use optional parameters or provide default values to achieve similar functionality.

- **`Access Modifiers:`** [Access modifiers](https://www.typescriptlang.org/docs/handbook/2/classes.html#public-private-and-protected-modifiers), which control the visibility and accessibility of class members (properties and methods). TypeScript provides three access modifiers: `public`, `private`, and `protected`. `public` members are accessible from outside the class, `private` members are only accessible within the class, and `protected` members are accessible within the class and its subclasses.

These fundamental concepts are crucial for creating well-structured and maintainable TypeScript code. Understanding function overloading, tuples, class structural typing, inheritance, constructors, and access modifiers empowers you to build object-oriented programs with TypeScript effectively.

- ### [Class 11 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Evening-section/Class-11)
- ### Online Recorded Sessions & videos üì∫:
  - [Function Overloading](https://youtu.be/OdTZYAJ37ng?si=Sb_hvfmoRPXV0JCP&t=240)
  - [Tuples](https://youtu.be/OvexMCKAXks?si=fnetL1GRKKAAIXjg&t=37)
  - [Classs and Objects](https://youtu.be/7RpdfkSyJfU?list=PLu0W_9lII9ahR1blWXxgSlL4y9iQBnLpR)
  - [Constructor](https://youtu.be/0E2akQ5E-5Y?list=PLu0W_9lII9ahR1blWXxgSlL4y9iQBnLpR)
  - [Access Modifiers - Public And Private](https://youtu.be/0m7hMRZdC2s?t=33), [Protected vs Readonly](https://youtu.be/Or9-VKzMZiQ?t=27)
  - [Inheritance & extends Keyword](https://youtu.be/9loYq8W8rsg?list=PLu0W_9lII9ahR1blWXxgSlL4y9iQBnLpR)

# NEXT JS.
- [**Class 12: Abstraction, Next.js, Server Side Rendering and Web 3, and Library vs. Framework**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-12-abstraction-nextjs-server-side-rendering-and-web-3-and-library-vs-framework)
- [**Class 13: NEXT.js Setup, .tsx Files, Routing, Linking, Grouping, and Layout Usage**](https://github.com/a-rehman-ujjan/PIAIC-Classes/blob/main/README.md#class-13-nextjs-setup-tsx-files-routing-linking-grouping-and-layout-usage)

# Getting Started Resources ‚öôÔ∏è
### [Learn Nextjs Step-by-Step](https://github.com/panaverse/learn-nextjs)

# Class 12: Abstraction, Next.js, Server Side Rendering and Web 3, and Library vs. Framework


- **`Abstraction in TypeScript:`** [Abstraction](https://www.javaguides.net/2019/09/typescript-abstraction-example.html) in typescript focuses on hiding complex implementation details while exposing essential features or functionalities of an object or a system. It allows developers to work with high-level concepts and hide the low-level implementation details. Abstraction helps in managing complexity and building more maintainable and understandable code. Abstraction is achieved through mechanisms like classes, interfaces, and abstract classes. You define an abstract interface that outlines the essential methods and properties, and then you implement this interface in concrete classes with specific implementations

- **`Abstract Class and Its Implementation:`** Abstract classes in TypeScript serve as blueprints for other classes. They allow you to define a common structure and set of methods that should be implemented by their child classes. Abstract classes cannot be instantiated on their own; they exist to be extended by other classes, and those child classes must provide concrete implementations for the abstract methods. Useful for creating a common structure for related classes. Abstract classes can also include concrete (non-abstract) methods with fully implemented code. These methods can be inherited and used by the child classes as is.
## Introduction to Next.js and React:

- **`What is React`** [React](https://react.dev/learn) is an open-source JavaScript library for building user interfaces. It was developed and is maintained by Facebook. React follows a component-based architecture. You create reusable UI components, which can be composed to build complex user interfaces. Each component encapsulates its own logic, structure, and appearance. React has a large and active community.

- **`What is Next.js:`** [Next.js](https://nextjs.org/learn/foundations/about-nextjs?utm_source=next-site&utm_medium=homepage-cta&utm_campaign=home) is a framework for building web applications with React. It provides a set of tools and conventions to simplify server-side rendering, routing, and other common tasks. One of the key features of Next.js is its support for `server-side rendering.` With SSR, initial page rendering happens on the server, which can improve page load times, enhance search engine optimization (SEO), and provide a better user experience. Next.js automatically splits your JavaScript code into smaller chunks, loading only the necessary code for the current page. This improves performance by reducing the initial bundle size. Next.js offers a great developer experience with features like hot module reloading, automatic code splitting, and support for CSS-in-JS libraries.

- **`Routing:`** Next.js includes a built-in routing system, simplifying the process of creating client-side navigation. You can define routes and link to different pages in your application. Next.js provides a convenient way to create serverless API endpoints within your application, making it easy to handle server-side logic without managing a separate backend.

- **`What is Server Side Rendering(SSR):`** In SSR, the web page is generated and rendered on the server before being sent to the client's browser. SSR typically results in faster initial page load times because the server sends a fully rendered HTML page to the client. The client can display content as soon as it receives the HTML. Search engines can easily crawl and index SSR pages because they receive complete HTML content from the server, SSR can be beneficial for users on slower devices or with limited processing power, as the server does most of the heavy lifting. Setting up SSR can be more complex than CSR, as it requires server-side rendering logic and may involve additional server-side libraries and configurations.

- **`What is Client Side Rendering(CSR):`** In CSR, the initial HTML page is minimal and often contains placeholders for content. JavaScript code running in the client's browser fetches data from a server and dynamically renders the page. Once the initial page is loaded, subsequent navigation within the application can be very fast because only data needs to be fetched and the page is re-rendered in the client. CSR is well-suited for single-page applications (SPAs) and complex, interactive web applications where content changes frequently without full page reloads. The initial page load can be slower as it requires downloading JavaScript files and making additional requests to fetch data and render content. Users may see placeholders until content loads. Search engines may have difficulty indexing CSR pages because the initial HTML often lacks content. While search engines have improved in handling CSR, SSR is still generally better for SEO. Many modern web applications use a combination of both SSR and CSR. For example, they might use SSR for the initial page load to ensure fast loading times and SEO benefits, then switch to CSR for subsequent navigation to provide a more interactive experience. The choice between SSR and CSR depends on your specific project requirements, including performance goals, SEO considerations, and the complexity of your application.

- **`Challenges with CSR in the Future (Web 3):`** Web 3, often associated with blockchain and decentralized applications, introduces new complexities.
  - These technologies can result in heavier web applications due to the need to interact with decentralized networks, manage cryptographic operations, and handle smart contracts.

  - CSR may struggle to meet the performance demands of Web 3 applications, especially when dealing with real-time data and complex decentralized computations. Users may experience slower load times and responsiveness.

  - Web 3 applications often rely on decentralized storage solutions like IPFS (InterPlanetary File System). Fetching data from these systems on the client side can introduce latency and challenges in handling large data sets.

  - To address these challenges, some applications opt for server-side rendering of 3D models. The server can pre-render the models and serve them as images or videos, reducing the client-side burden.

- **`Planet Scale Interlinked Websites:`** As the web evolves, we're seeing the emergence of planet-scale interconnected websites that span across diverse domains, platforms, and ecosystems. These interconnected sites share data and services seamlessly.
  - Managing data exchange and interoperability across these interconnected sites can be highly complex. CSR, which traditionally relies on fetching data from specific APIs, may struggle to adapt to this interconnected landscape.

  - Interlinked websites raise concerns about data privacy and security, as data might be shared across various platforms. Handling user data securely becomes paramount, and CSR might face challenges in ensuring secure data transmission.

- **`Library vs. Framework:`**
  - `library` is a collection of pre-written code modules or functions that developers can use in their applications. Libraries are designed to perform specific tasks or provide specific functionalities, and developers can call these functions as needed within their code. developers retain full control over the flow of their application. They can choose which functions from the library to use and when to use them. Libraries do not impose a specific structure or design pattern on the application. Libraries are often more flexible because they can be used in a variety of projects, and developers can integrate them into their codebase as needed. There's typically no strict reliance on the library's structure or conventions.

  - `Framework` is a comprehensive, pre-built software structure that dictates the overall structure and flow of an application. Frameworks provide a skeletal architecture where developers plug in their code to build specific features. They often enforce specific design patterns and conventions. developers have less control over the application's flow because the framework defines the application's architecture. Developers follow the framework's guidelines and conventions, which can lead to a consistent and structured application. Frameworks are often opinionated, meaning they prescribe a particular way of doing things. This can lead to faster development because many decisions are already made for the developer. However, it may also limit flexibility.

  - `Control vs. Convention:` Libraries provide more control and flexibility because developers decide when and how to use them. Frameworks follow specific conventions and impose a structured approach.

  - `Use Case:` Libraries are often used to add specific functionality to an existing codebase. Frameworks are used to build entire applications with a predefined structure.

  - `Learning Curve:` Libraries typically have a lower learning curve because developers can pick and choose which parts to use. Frameworks may have a steeper learning curve due to their comprehensive structure and conventions.

  - `Development Speed:` Frameworks can speed up development by providing a structured foundation. Libraries are used to enhance specific parts of an application, potentially leading to a more customized but slower development process.

In this class, you explored a range of topics, from abstraction and abstract classes in TypeScript to the concepts of Next.js, server-side rendering, and the potential challenges posed by Web 3 technologies. Additionally, you learned about the differences between libraries and frameworks in the context of web development.

- ### [Class 12 Code](https://github.com/usmanashrf/typescript-batch48/tree/main/Evening-section/Class-12)
- ### Online Recorded Sessions & videos üì∫:
  - [Abstract Class](https://youtu.be/1JvHkO48GWQ)
  - [What is React](https://youtu.be/Tn6-PIqc4UM)
  - [What is Next.js](https://youtu.be/Sklc_fQBmcs)
  - [Client-Side VS Server-Side Rendering](https://youtu.be/f1rF9YKm1Ms)
  - [What is PlanetScale](https://youtu.be/e63OWkVmawY)
  - [Library vs. Framework vs. language](https://youtu.be/K5DHRtLBLJM)

# Class 13: NEXT.js Setup, .tsx Files, Routing, Linking, Grouping, and Layout Usage

- [**`Penaverse Nextjs Step-by-Step`**](https://github.com/panaverse/learn-nextjs)

- **`NEXT.js Setup`**:
  - Ensure you have [Node.js](https://nodejs.org/) and npm (Node Package Manager) installed on your computer.

  - Create a next js application run `npx create-next-app@latest` in your terminal or command prompt. this will ask you the name of your application.

  - Make sure after creating a new project you Change your working directory to the newly created project folder, you can type `cd (folder_name)` to do that.

  - To run your NEXT.js application, use the following command `npm run dev` This command typically runs your application on **http://localhost:3000/**

  - To make changes spot `page.tsx` inside src/app in your folder. make changes in that file, you can modify layout.tsx to make changes in the appearance of your application using [Tailwindcss](https://tailwindcss.com/).

- **`.tsx File Extension:`** The **.tsx** file extension is used for TypeScript files that contain React components. this extension indicates that the file is written in TypeScript (a statically typed superset of JavaScript) and contains JSX (JavaScript XML) syntax. JSX is a syntax extension for JavaScript often used with React to describe the structure and appearance of user interfaces.

  - **JSX:** JSX is a syntax extension for JavaScript that allows developers to write HTML-like code within JavaScript or TypeScript files. It's commonly used with React to define the structure of UI components.

  - **React Components:** In the context of React, `.tsx` files typically contain React component definitions. These components can be functional components or class components, and they describe how a part of the user interface should be rendered based on the component's props and state.

  - By using TypeScript and the .tsx extension, developers can leverage static type checking while building React applications, which helps catch errors early in the development process and improves code quality and maintainability.

- **`Routing in NEXT.js:`** [Routing in NEXT.js](https://nextjs.org/docs/pages/building-your-application/routing) refers to the process of defining how URLs (Uniform Resource Locators) map to different pages or components in your NEXT.js application. Routing allows you to create a navigational structure for your web application, enabling users to access different views or sections of your site by clicking on links or typing URLs in their browsers. Routing is a fundamental aspect of building web applications, and NEXT.js simplifies it by providing a page-based routing system and convenient tools like the Link component for client-side navigation.

- **`Linking in NEXT.js:`** [Linking in NEXT.js](https://nextjs.org/learn/basics/navigate-between-pages/link-component) refers to the process of creating navigational links within your NEXT.js application using the Link component. The Link component is a built-in feature of NEXT.js that simplifies client-side navigation between different pages or views of your application without requiring full page reloads. It is part of the framework's routing system and plays a crucial role in creating a smooth and responsive user experience. Using Link components for navigation is a common practice in NEXT.js applications, as it simplifies routing and ensures that navigation is fast and efficient, contributing to a more smooth user experience.

- **`Grouping in NEXT.js:`** Grouping in NEXT.js or [Route Groups](https://nextjs.org/docs/app/building-your-application/routing/route-groups) refers to the process of organizing and grouping related routes or pages within your NEXT.js application. This feature allows you to create a structured and modular project layout, making it easier to manage your application as it grows in complexity. Grouping is achieved using a special feature called "File System Routing" provided by NEXT.js. Grouping in NEXT.js provides a structured and organized approach to building web applications, making it easier to manage routes and related components as your project grows. It encourages modularization and code reusability, enhancing the maintainability of your application.

- **`layout.tsx and Global Usage:`** In NEXT.js, a [layout.tsx](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts) file is a React component that defines the common structure and layout for multiple pages within your application. It serves as a template that encapsulates the shared design, header, footer, or other elements that should appear consistently across various pages. The primary purpose of layout.tsx is to provide a consistent and unified user interface across different parts of your application. By using a layout component, you can reuse the same layout structure across multiple pages without duplicating code. This promotes code reusability and reduces maintenance efforts.

  - **Global Usage:** Global usage of the layout.tsx component involves applying it to multiple pages to ensure a consistent user experience throughout your application. When you use the `layout.tsx` component globally, all pages wrapped with this layout will share the same UI elements, creating a cohesive user experience. when you create a new folder with name in the parenthesis() to indicate it is a group you create multiple folders that are routes grouped, you can create one `layout.tsx` in that folder whose name is written in the parenthesis which will modify the styling of all pages in that group of routes.

  - **Individual Page Usage:** While `layout.tsx` can be used globally, you can also apply it selectively to individual pages when customization is needed, when you create a new folder with the route name in the src/app you create a page.tsx file in that folder that contains the code for that path's data, you can create a new `layout.tsx` file in that same folder to modify the styling of that particular page.

- ### [Class 13 Code & Nextjs Project Example](https://github.com/usmanashrf/typescript-batch48/tree/main/Evening-section/nextj_proj/batch48-firstclass)
- ### Online Recorded Sessions & videos üì∫:
  - [Nextjs Setup](https://youtu.be/gV_BsB1rGBU?t=21)
  - [Routing in Nextjs](https://youtu.be/k2IQ-CcE7pk)
  - [Grouping in Nextjs](https://youtu.be/MyVQ0TU-HcQ)
  - [Linking in Nextjs](https://youtu.be/u8vaAc3ivcY)
  - [Layouts in Nextjs](https://youtu.be/xWjpaDNWndA?list=PLuHGmgpyHfRx5FPRKBE7TvVYeIypTWIm9)

Remember, each class builds on the previous ones, deepening your understanding of TypeScript and web development concepts. For detailed information about each topic, [class slides](https://docs.google.com/presentation/d/1-7Kb3laJjJ68mOTF9v0fHImk5vTol0CeE43Sg8hoUXQ/mobilepresent#slide=id.gcb9a0b074_1_0).

Feel free to explore the topics further through online resources, video tutorials, and hands-on practice. Happy learning!


